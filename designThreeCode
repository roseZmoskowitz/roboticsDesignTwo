#pragma config(Sensor, in1,    pot,            sensorAnalog)
#pragma config(Sensor, dgtl1,  lquad,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rquad,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  equad,          sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  aquad,          sensorQuadEncoder)
#pragma config(Motor,  port1,           tlift,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rf,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rb,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           arm,           tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           mlift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           mg,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lb,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           lf,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          blift,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task drive()
{
	int threshold = 10;
	while(1==1)
	{

		if (vexRT[Btn8R] == 1)
		{
			while(vexRT[Btn8L] == 0 && vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)
			{

				if(abs(vexRT[Ch3]) > threshold)
				{
					motor[lf]  = vexRT[Ch3];
					motor[lb]  = vexRT[Ch3];

				}
				else
				{
					motor[lf]  = 0;
					motor[lb]  = 0;
				}

				if(abs(vexRT[Ch2]) > threshold)
				{
					motor[rb] = vexRT[Ch2];
					motor[rf] = vexRT[Ch2];
				}
				else
				{
					motor[rb] = 0;
					motor[rf] = 0;
				}
				EndTimeSlice();
			}
		}

		else	if (vexRT[Btn8L] == 1)
		{
			while(vexRT[Btn8R] == 0 && vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)
			{

				if(abs(vexRT[Ch3]) > threshold)
				{
					motor[rb]  = -vexRT[Ch3];
					motor[rf]  = -vexRT[Ch3];

				}
				else
				{
					motor[rb]  = 0;
					motor[rf]  = 0;
				}

				if(abs(vexRT[Ch2]) > threshold)
				{
					motor[lf] = -vexRT[Ch2];
					motor[lb] = -vexRT[Ch2];
				}
				else
				{
					motor[lf] = 0;
					motor[lb] = 0;
				}
				EndTimeSlice();
			}
		}
		else	if (vexRT[Btn5U] == 1)
		{
			motor[lf]  = -30;
			motor[lb]  = -30;
			motor[rf]  = -30;
			motor[rb]  = -30;
		}
		else	if (vexRT[Btn5D] == 1)
		{
			motor[lf]  = 30;
			motor[lb]  = 30;
			motor[rf]  = 30;
			motor[rb]  = 30;
		}
		else
		{

			motor[lf]  = 0;
			motor[lb]  = 0;
			motor[rf]  = 0;
			motor[rb]  = 0;
		}
	}
}






void stackup (int count1, int count2, int count3)
{

	float myP = 0.5;  // Proportional:  increase if you have a robot with high interia.
	float myI = 1;	// Integeral:

	float error=0.0;
	float motor_speed;
	float sumI=0.0;		// Sum of the integeral error
	int target = 700; //vertical


	SensorValue[aquad] = 0; //Clear the encoders
	motor[arm] = 0;

	//error = target - abs(SensorValue[aquad]);

	startMotor(tlift, -127);
	startMotor(mlift, -127);
	startMotor(blift, -127);

	while (abs(SensorValue[equad])< count1 && vexRT[Btn8LXmtr2] == 0)
	{
		/*error = target - abs(SensorValue[aquad]);

		sumI = sumI + myI * error;
		if (sumI > 15) sumI=15;
		if (sumI < -15) sumI=-15;
		motor_speed = (myP * error) + sumI;

		motor[arm] = motor_speed;*/
		startMotor(tlift, -127);
		startMotor(mlift, -127);
		startMotor(blift, -127);

		EndTimeSlice();
	}
	while (abs(SensorValue[equad])< count2 && vexRT[Btn8LXmtr2] == 0)
	{
		/*error = target - abs(SensorValue[aquad]);

		sumI = sumI + myI * error;
		if (sumI > 15) sumI=15;
		if (sumI < -15) sumI=-15;
		motor_speed = (myP * error) + sumI;

		motor[arm] = motor_speed;*/
		startMotor(tlift, -127);
		startMotor(mlift, -127);
		startMotor(blift, -127);
		motor[arm] = 127;

		EndTimeSlice();
	}
	while( abs(SensorValue[equad])< count3 && vexRT[Btn8LXmtr2] == 0) // just for 1 second
	{
		motor[arm] = 40;

		EndTimeSlice();
	}
	motor[arm] = 0;
	motor[tlift] = 0;
	motor[mlift] = 0;
	motor[blift] = 0;

}


void stackdown (int target, int count)
{
	float myP = 1.2;  // Proportional:  increase if you have a robot with high interia.
	float myI = 1;	// Integeral:

	float error=0.0;
	float motor_speed;
	float sumI=0.0;		// Sum of the integeral error


	//SensorValue[equad] = 0; //Clear the encoders
	motor[tlift] = 0;
	motor[mlift] = 0;
	motor[blift] = 0;

	error = target - abs(SensorValue[equad]);

	if (abs(SensorValue[equad])< target)
	{
		setServo(claw,60); //90
		motor[arm] = -80;

		while (vexRT[Btn8LXmtr2] == 0 && time1[T1]<500)//0.5 sec
		{
			error = target - abs(SensorValue[equad]);

			sumI = sumI + myI * error;
			if (sumI > 30) sumI=30;
			if (sumI < -30) sumI=-30;
			motor_speed = (myP * error) + sumI;

			motor[tlift] = -motor_speed;
			motor[mlift] = -motor_speed;
			motor[blift] = -motor_speed;

			EndTimeSlice();
		}

		setServo(claw,60);//90
		//	wait(1);

		motor[arm] = -127;


		while (abs(SensorValue[aquad])> 1000 && vexRT[Btn8LXmtr2] == 0) //until small endoder count
		{
			error = target - abs(SensorValue[equad]);

			sumI = sumI + myI * error;
			if (sumI > 40) sumI=40;
			if (sumI < -40) sumI=-40;
			motor_speed = (myP * error) + sumI;

			motor[tlift] = -motor_speed;
			motor[mlift] = -motor_speed;
			motor[blift] = -motor_speed;
			setServo(claw,30); //70
			EndTimeSlice();
		}

		while( abs(SensorValue[aquad])> 750 && vexRT[Btn8LXmtr2] == 0) //until vertical
		{
			motor[arm] = -127;
			motor[tlift] = 127;
			motor[mlift] = 127;
			motor[blift] = 127;
			setServo(claw,30); //70
			EndTimeSlice();
		}
		while( abs(SensorValue[equad])> count && vexRT[Btn8LXmtr2] == 0)
		{
			motor[arm] = 0;
			motor[tlift] = 127;
			motor[mlift] = 127;
			motor[blift] = 127;
			setServo(claw,30); //70
			EndTimeSlice();
		}
		motor[arm] = 0;
		motor[tlift] = 0;
		motor[mlift] = 0;
		motor[blift] = 0;
		setServo(claw,50); //80
		//	SensorValue[equad] = 0;

	}
	else
	{

		while( abs(SensorValue[aquad])> 1000 && vexRT[Btn8LXmtr2] == 0) //until small endoder count
		{
			motor[arm] = -127;
			setServo(claw, 30); //70
			EndTimeSlice();
		}
		while( abs(SensorValue[aquad])> 900 && vexRT[Btn8LXmtr2] == 0) //until small endoder count
		{
			motor[arm] = -127;
			setServo(claw, 30);//70
			EndTimeSlice();
		}
		while( abs(SensorValue[aquad])> 750 && vexRT[Btn8LXmtr2] == 0) //until vertical
		{

			motor[arm] = -127;
			motor[tlift] = 127;
			motor[mlift] = 127;
			motor[blift] = 127;
			EndTimeSlice();
		}
		while( abs(SensorValue[equad])> count && vexRT[Btn8LXmtr2] == 0)
		{
			motor[arm] = 0;
			motor[tlift] = 127;
			motor[mlift] = 127;
			motor[blift] = 127;
			EndTimeSlice();
		}
		motor[arm] = 0;
		motor[tlift] = 0;
		motor[mlift] = 0;
		motor[blift] = 0;
		setServo(claw, 50); //80
		//	SensorValue[equad] = 0;
	}
}

void stackup1 (int count1, int count2)
{
	SensorValue[aquad] = 0; //Clear the encoders
	while (abs(SensorValue[equad])< count1 && vexRT[Btn8LXmtr2] == 0)
	{

		startMotor(tlift, -127);
		startMotor(mlift, -127);
		startMotor(blift, -127);
		motor[arm] = 127;
		EndTimeSlice();
	}
	motor[tlift] = 0;
	motor[mlift] = 0;
	motor[blift] = 0;
	//SensorValue[equad] = 0;

	while (abs(SensorValue[aquad])< count2 && vexRT[Btn8LXmtr2] == 0)
	{
		motor[arm] = 127;

		EndTimeSlice();
	}
	motor[arm] = 0;

}

 

task pinch()
{
	setServo(claw,-30);
	while (1==1)
	{
		int v = motor(claw);
		if (vexRT[Btn5UXmtr2] == 1)
		{
			if (v == -30)//0
			{

				setServo(claw,50); //80
				wait (0.5);
			}
			else if (v == 50) //80
			{
				setServo(claw,-30); //0
				wait (0.5);
			}
		}

		EndTimeSlice();
	}

}

task mobilegoal()
{
	while (1==1)
	{
		if(vexRT[Btn6U] == 1)
		{
			motor[mg] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[mg] = -127;
		}
		else
		{
			motor[mg] = 0;
		}

		if(vexRT[Btn7L] == 1)
		{
			SensorValue[equad] = 0;

		}
		if(vexRT[Btn7R] == 1)
		{
			SensorValue[aquad] = 0;
		}

		EndTimeSlice();
	}
}



task main()
{
	startTask(drive);
	startTask(mobilegoal);
	startTask(pinch);
	SensorValue[equad] = 0;
	//SensorValue[aquad] = 0;
	while(1 == 1)
	{

		if(vexRT[Btn7UXmtr2] == 1)
		{

			while (vexRT[Btn7RXmtr2] == 0 && vexRT[Btn7DXmtr2] == 0 && vexRT[Btn7LXmtr2] == 0 && vexRT[Btn8UXmtr2] == 0 && vexRT[Btn8DXmtr2] == 0 && vexRT[Btn8RXmtr2]==0 && vexRT[Btn5DXmtr2]==0 && vexRT[Btn8D]==0 && vexRT[Btn8U]==0)
			{
				if(vexRT[Btn6UXmtr2] == 1)
				{
					while (abs(SensorValue[aquad])< 800 && vexRT[Btn8LXmtr2] == 0)
					{
						motor[arm] = 127;
					}
				}
				else if(vexRT[Btn6DXmtr2] == 1)
				{
					setServo(claw,30); //70
					while (abs(SensorValue[aquad])> 700 && vexRT[Btn8LXmtr2] == 0)
					{
						motor[arm] = -127;
					}
					motor[arm] = 0;
					setServo(claw,50); //80
				}
				else
				{
					motor[arm] = 0;

				}
				EndTimeSlice();
			}
		}


		else	if(vexRT[Btn7RXmtr2] == 1)
		{
			while (vexRT[Btn7UXmtr2] == 0 && vexRT[Btn7DXmtr2] == 0 && vexRT[Btn7LXmtr2] == 0 && vexRT[Btn8UXmtr2] == 0 && vexRT[Btn8DXmtr2] == 0 && vexRT[Btn8RXmtr2]==0 && vexRT[Btn5DXmtr2]==0 && vexRT[Btn8D]==0 && vexRT[Btn8U]==0)
			{
				if(vexRT[Btn6UXmtr2] == 1)
				{
					stackup1(200, 800);
				}
				else if(vexRT[Btn6DXmtr2] == 1)
				{
					clearTimer(T1);
					stackdown(150, 0);
				}
				else
				{
					motor[arm] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

				}
				EndTimeSlice();
			}
		}

		else	if(vexRT[Btn7DXmtr2] == 1)
		{
			while (vexRT[Btn7RXmtr2] == 0 && vexRT[Btn7UXmtr2] == 0 && vexRT[Btn7LXmtr2] == 0 && vexRT[Btn8UXmtr2] == 0 && vexRT[Btn8DXmtr2] == 0 && vexRT[Btn8RXmtr2]==0 && vexRT[Btn5DXmtr2]==0 && vexRT[Btn8D]==0 && vexRT[Btn8U]==0)
			{
				if(vexRT[Btn6UXmtr2] == 1)
				{
					stackup(250, 550, 650);
				}
				else if(vexRT[Btn6DXmtr2] == 1)
				{
					clearTimer(T1);
					stackdown(600, 0);
				}
				else
				{
					motor[arm] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

				}
				EndTimeSlice();
			}
		}

		else if(vexRT[Btn7LXmtr2] == 1)
		{
			while (vexRT[Btn7RXmtr2] == 0 && vexRT[Btn7DXmtr2] == 0 && vexRT[Btn7UXmtr2] == 0 && vexRT[Btn8UXmtr2] == 0 && vexRT[Btn8DXmtr2] == 0 && vexRT[Btn8RXmtr2]==0 && vexRT[Btn5DXmtr2]==0 && vexRT[Btn8D]==0 && vexRT[Btn8U]==0)
			{
				if(vexRT[Btn6UXmtr2] == 1)
				{
					stackup(525, 825, 925);
				}
				else if(vexRT[Btn6DXmtr2] == 1)
				{
					clearTimer(T1);
					stackdown(825, 0);
				}
				else
				{
					motor[arm] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

				}
				EndTimeSlice();
			}
		}




		else if(vexRT[Btn8RXmtr2] == 1)
		{
			float myP = 1.2;  // Proportional:  increase if you have a robot with high interia.
			float myI = 1;	// Integeral:

			float error=0.0;
			float motor_speed;
			float sumI=0.0;		// Sum of the integeral error
			int target = 510;

			//Clear the encoders
			//SensorValue[aquad] = 0;
			motor[tlift] = 0;
			motor[mlift] = 0;
			motor[blift] = 0;


			error = abs(SensorValue[equad]) - target;
			while (vexRT(Btn8LXmtr2) == 0)
			{
				error = abs(SensorValue[equad]) - target;

				sumI = sumI + myI * error;
				if (sumI > 30) sumI=30;
				if (sumI < -30) sumI=-30;
				motor_speed = (myP * error) + sumI;

				motor[tlift] = motor_speed;
				motor[mlift] = motor_speed;
				motor[blift] = motor_speed;

				EndTimeSlice();
			}
			motor[tlift] = 0;
			motor[mlift] = 0;
			motor[blift] = 0;
		}


		else if(vexRT[Btn8DXmtr2] == 1)
		{
			while (vexRT[Btn7RXmtr2] == 0 && vexRT[Btn7DXmtr2] == 0 && vexRT[Btn7LXmtr2] == 0 && vexRT[Btn8UXmtr2] == 0 && vexRT[Btn7UXmtr2] == 0 && vexRT[Btn8RXmtr2] == 0 && vexRT[Btn5DXmtr2]==0 && vexRT[Btn8D]==0 && vexRT[Btn8U]==0)
			{
				if(vexRT[Btn6UXmtr2] == 1)
				{
					stackup1(510, 800);
				}
				else if(vexRT[Btn6DXmtr2] == 1)
				{
					clearTimer(T1);
					stackdown(750, 700);

					float myP = 1.2;  // Proportional:  increase if you have a robot with high interia.
					float myI = 1;	// Integeral:

					float error=0.0;
					float motor_speed;
					float sumI=0.0;		// Sum of the integeral error
					int target = 700;

					//Clear the encoders
					//SensorValue[aquad] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

					clearTimer(T1);

					error = abs(SensorValue[equad]) - target;
					while (vexRT(Btn8LXmtr2) == 0 && time1[T1]<500)
					{
						error = abs(SensorValue[equad]) - target;

						sumI = sumI + myI * error;
						if (sumI > 30) sumI=30;
						if (sumI < -30) sumI=-30;
						motor_speed = (myP * error) + sumI;

						motor[tlift] = motor_speed;
						motor[mlift] = motor_speed;
						motor[blift] = motor_speed;

						EndTimeSlice();
					}
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

					target = 510;

					//Clear the encoders
					//SensorValue[aquad] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;


					error = abs(SensorValue[equad]) - target;
					while (vexRT(Btn8LXmtr2) == 0)
					{
						error = abs(SensorValue[equad]) - target;

						sumI = sumI + myI * error;
						if (sumI > 30) sumI=30;
						if (sumI < -30) sumI=-30;
						motor_speed = (myP * error) + sumI;

						motor[tlift] = motor_speed;
						motor[mlift] = motor_speed;
						motor[blift] = motor_speed;

						EndTimeSlice();
					}
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;
				}
				else
				{
					motor[arm] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

				}
				EndTimeSlice();
			}
		}


		else if(vexRT[Btn8UXmtr2] == 1)
		{
			while (vexRT[Btn7RXmtr2]==0 && vexRT[Btn7DXmtr2]==0 && vexRT[Btn7LXmtr2]==0 && vexRT[Btn7UXmtr2]==0 && vexRT[Btn8DXmtr2]==0 && vexRT[Btn8RXmtr2]==0 && vexRT[Btn5DXmtr2]==0 && vexRT[Btn8D]==0 && vexRT[Btn8U]==0)
			{
				if(vexRT[Btn6UXmtr2] == 1)
				{
					stackup(525, 825, 925);
				}
				else if(vexRT[Btn6DXmtr2] == 1)
				{
					clearTimer(T1);
					stackdown(825, 700);
					float myP = 1.2;  // Proportional:  increase if you have a robot with high interia.
					float myI = 1;	// Integeral:

					float error=0.0;
					float motor_speed;
					float sumI=0.0;		// Sum of the integeral error
					int target = 700;

					//Clear the encoders
					//SensorValue[aquad] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;
					clearTimer(T1);


					error = abs(SensorValue[equad]) - target;
					while (vexRT(Btn8LXmtr2) == 0 && time1[T1]<500)
					{
						error = abs(SensorValue[equad]) - target;

						sumI = sumI + myI * error;
						if (sumI > 30) sumI=30;
						if (sumI < -30) sumI=-30;
						motor_speed = (myP * error) + sumI;

						motor[tlift] = motor_speed;
						motor[mlift] = motor_speed;
						motor[blift] = motor_speed;

						EndTimeSlice();
					}
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

					target = 510;

					//Clear the encoders
					//SensorValue[aquad] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;


					error = abs(SensorValue[equad]) - target;
					while (vexRT(Btn8LXmtr2) == 0)
					{
						error = abs(SensorValue[equad]) - target;

						sumI = sumI + myI * error;
						if (sumI > 30) sumI=30;
						if (sumI < -30) sumI=-30;
						motor_speed = (myP * error) + sumI;

						motor[tlift] = motor_speed;
						motor[mlift] = motor_speed;
						motor[blift] = motor_speed;

						EndTimeSlice();
					}
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;
				}
				else
				{
					motor[arm] = 0;
					motor[tlift] = 0;
					motor[mlift] = 0;
					motor[blift] = 0;

				}
				EndTimeSlice();
			}
		}


		else if(vexRT[Btn5DXmtr2] == 1)
		{
			motor[tlift] = 127;
			motor[mlift] = 127;
			motor[blift] = 127;
		}

		else if(vexRT[Btn8U] == 1)
		{
			motor[arm] = 127;


		}
		else if(vexRT[Btn8D] == 1)
		{
			motor[arm] = -127;

		}

		else
		{
			motor[arm] = 0;
			motor[tlift] = 0;
			motor[mlift] = 0;
			motor[blift] = 0;
		}


		EndTimeSlice();
	}

}
